COMPILER Taste

CHARACTERS
  letter = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".
  digit = "0123456789".
  cr  = '\r'.
  lf  = '\n'.
  tab = '\t'.

TOKENS
  ident  = letter {letter | digit}.
  number = digit {digit}.

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab

PRODUCTIONS

AddOp<var op: TOp>
=                            (. op := TOp.ADD; .)
( '+'
| '-'                        (. op := TOp.SUB; .)
).

Expr<var typ: Integer>       (. var
                                  type1: Integer;
                                  op: TOp; .)
= SimExpr<typ>
[ RelOp<op>
SimExpr<typ1>                (. if typ <> typ1 then Error('incompatible types');
                                gen.Emit(op);
                                typ := boolean; .)
].

Factor<var typ: Integer>     (. var
                                  n: Integer;
                                  obj: Obj;
                                  name: string; .)
=                            (. typ := undef; .)
( Ident<name>                (. obj := tab.Find(name);
                                typ := obj.typ;
                                if obj.kind = var then
                                begin
                                  if obj.level = 0 then
                                    gen.Emit(TOp.LOADG, obj.adr)
                                  else
                                    gen.Emit(TOp.LOAD, obj.adr);
                                end else
                                  Error('variable expected'); .)
| number                     (. n := Convert.ToInt32(t.val);
                                gen.Emit(TOp.CONST, n);
                                typ := integer; .)
| '-' Factor<typ>            (. if typ <> integer then
                                begin
                                  Error('integer type expected');
                                  typ := integer;
                                end;
                                gen.Emit(TOp.NEG); .)
| "true"                     (. gen.Emit(TOp.CONST, 1);
                                typ := boolean; .)
| "false"                    (. gen.Emit(TOp.CONST, 0);
                                typ := boolean; .)
).

Ident<var name: string>
= ident                      (. name := t.val; .)
.

MulOp<var op: TOp>
=                            (. op := TOp.MUL; .)
  ( '*'
  | '/'                      (. op := TOp.opDIV; .)
  )
.

ProcDecl                     (. var
                                  name: string;
                                  obj: TObj;
                                  adr: Integer; .)
=
"procedure" Ident<name>      (. obj := tab.NewObj(name, proc, undef);
                                obj.adr := gen.pc;
                                if name = 'Main' then
                                  gen.progStart := gen.pc;
                                tab.OpenScope; .)
  '(' ')'
  '{'                        (. gen.Emit(TOp.ENTER, 0);
                                adr := gen.pc - 2; .)
  { VarDecl | Stat }
  '}'                        (. gen.Emit(TOp.LEAVE);
                                gen.Emit(TOp.RET);
                                gen.Patch(adr, tab.topScope.nextAdr);
                                tab.CloseScope; .).

RelOp<var op: TOp>
=                            (. op := TOp.EQU; .)
  ( '='
  | '<'                      (. op := TOp.LSS; .)
  | '>'                      (. op := TOp.GTR; .)
  ).

SimExpr<var typ: Integer>    (. var
                                  typ1: Integer;
                                  op: TOp; .)
=
Term<typ>
{ AddOp<op>
  Term<typ1>                 (. if (typ <> integer) or (typ1 <> integer) then
                                  Error('integer type expected');
                                gen.Emit(op); .)
}.

Stat                         (. var
                                  typ: Integer;
                                  name: string;
                                  obj: TObj;
                                  adr, adr2, loopstart: Integer; .)
=
Ident<name>                  (. obj := tab.Find(name); .)
( ":="                       (. if obj.kind <> var then
                                  Error('cannot assign to procedure'); .)
Expr<typ> ';'                (. if typ <> obj.typ then
                                  Error('incompatible types');
                                if obj.level = 0 then
                                  gen.Emit(TOp.STOG, obj.adr)
                                else
                                  gen.Emit(TOp.STO, obj.adr); .)
| '(' ')' ';'                (. if obj.kind <> proc then
                                  Error('object is not a procedure');
                                gen.Emit(TOp.CALL, obj.adr); .)
)
| "if"
  Expr<typ> "then"          (. if typ <> boolean then
                                  Error('boolean type expected');
                                gen.Emit(TOp.FJMP, 0);
                                adr := gen.pc - 2; .)
Stat
[ "else"                     (. gen.Emit(TOp.JMP, 0);
                                adr2 := gen.pc - 2;
                                gen.Patch(adr, gen.pc);
                                adr := adr2; .)
  Stat ]                     (. gen.Patch(adr, gen.pc); .)

| "while"                    (. loopstart := gen.pc; .)
  '(' Expr<typ> ')'          (. if typ <> boolean then
                                  Error('boolean type expected');
                                gen.Emit(TOp.FJMP, 0);
                                adr := gen.pc - 2; .)
  Stat                       (. gen.Emit(TOp.JMP, loopstart);
                                gen.Patch(adr, gen.pc); .)

| "read"
  Ident<name> ';'            (. obj := tab.Find(name);
                                if obj.typ <> integer then
                                  Error('integer type expected');
                                gen.Emit(TOp.READ);
                                if obj.level = 0 then
                                  gen.Emit(TOp.STOG, obj.adr)
                                else
                                  gen.Emit(TOp.STO, obj.adr); .)

| "write"
  Expr<typ> ';'               (. if typ <> integer then
                                   Error('integer type expected');
                                 gen.Emit(TOp.WRITE); .)

| '{' { Stat | VarDecl } '}'
.

Taste                        (. var
                                  name: string; .)
= "program"
  Ident<name>                (. tab.OpenScope; .)
  '{'
  { VarDecl | ProcDecl }
  '}'                        (. tab.CloseScope;
                                if gen.progStart = -1 then
                                  Error('main function never defined'); .)
.

Term<var typ: Integer>       (. var
                                  typ1: Integer;
                                  op: TOp; .)
=
Factor<typ>
{ MulOp<op>
Factor<typ1>                 (. if (typ <> integer) or (typ1 <> integer) then
                                  Error('integer type expected');
                                gen.Emit(op); .)
}.

typ<var typ: Integer>
=                            (. typ := undef; .)
( "Integer"                  (. typ := integer; .)
| "boolean"                  (. typ := boolean; .)
).

VarDecl                      (. var
                                  name: string;
                                  typ: Integer; .)
=
typ<typ>
Ident<name>                  (. tab.NewObj(name, var, typ); .)
{ ',' Ident<name>            (. tab.NewObj(name, var, typ); .)
} ';'
.

END Taste.

